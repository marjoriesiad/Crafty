const express = require('express');
const bodyParser = require('body-parser');
const { Client, GatewayIntentBits, EmbedBuilder, PermissionFlagsBits } = require('discord.js');
require('dotenv').config();

// === Configuration Express ===
const app = express();
app.use(bodyParser.json());

// === Configuration Discord ===
const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent,
    GatewayIntentBits.GuildMessageReactions, // Pour les r√©actions
    GatewayIntentBits.GuildMembers // Pour g√©rer les r√¥les
  ],
});

// === Configuration du syst√®me de r√¥les ===
const ROLE_CONFIG = {
  PROJECT_ROLE_NAME: 'Projets', // Nom du r√¥le √† attribuer
  REACTION_EMOJI: 'üîî', // Emoji pour les r√©actions
  SETUP_CHANNEL_ID: process.env.SETUP_CHANNEL_ID, // Canal pour le message de setup
  PROJECT_ANNOUNCE_CHANNEL_ID: process.env.PROJECT_ANNOUNCE_CHANNEL_ID // Canal des annonces
};

// === Bot Discord - √âv√©nements ===
client.once('ready', async () => {
  console.log(`‚úÖ Connect√© en tant que ${client.user.tag}`);
  console.log(`üîî Syst√®me de r√¥les configur√© avec l'emoji ${ROLE_CONFIG.REACTION_EMOJI}`);
  console.log(`üéØ R√¥le configur√© : ${ROLE_CONFIG.PROJECT_ROLE_NAME}`);
  
  // Optionnel : Cr√©er automatiquement le message de r√¥le au d√©marrage
  if (process.env.AUTO_SETUP_ROLES === 'true') {
    console.log('üöÄ Configuration automatique des r√¥les...');
    await setupRoleMessage();
  }
});

// === Syst√®me de r√¥les automatique ===

// Fonction pour cr√©er/r√©cup√©rer le r√¥le
async function ensureProjectRole(guild) {
  try {
    // Chercher le r√¥le existant
    let role = guild.roles.cache.find(r => r.name === ROLE_CONFIG.PROJECT_ROLE_NAME);
    
    // Cr√©er le r√¥le s'il n'existe pas
    if (!role) {
      role = await guild.roles.create({
        name: ROLE_CONFIG.PROJECT_ROLE_NAME,
        color: '#3498db', // Bleu
        reason: 'R√¥le automatique pour les notifications de projets SkillCraft',
        mentionable: true, // Permet de mentionner le r√¥le
        permissions: [] // Aucune permission sp√©ciale
      });
      console.log(`‚úÖ R√¥le "${ROLE_CONFIG.PROJECT_ROLE_NAME}" cr√©√© avec succ√®s`);
    }
    
    return role;
  } catch (error) {
    console.error('‚ùå Erreur lors de la cr√©ation du r√¥le:', error);
    return null;
  }
}

// Fonction pour cr√©er le message de setup des r√¥les
async function setupRoleMessage() {
  try {
    const channelId = ROLE_CONFIG.SETUP_CHANNEL_ID || ROLE_CONFIG.PROJECT_ANNOUNCE_CHANNEL_ID;
    if (!channelId) {
      console.error('‚ùå Aucun canal configur√© pour le setup des r√¥les');
      return false;
    }

    const channel = await client.channels.fetch(channelId);
    if (!channel) {
      console.error('‚ùå Canal non trouv√© pour le setup des r√¥les');
      return false;
    }

    // Cr√©er l'embed pour le message de r√¥le
    const embed = new EmbedBuilder()
      .setTitle('üîî Notifications de Projets SkillCraft')
      .setDescription(`Restez inform√© des nouveaux projets cr√©√©s sur SkillCraft !
      
**Comment √ßa marche ?**
‚Ä¢ Cliquez sur ${ROLE_CONFIG.REACTION_EMOJI} ci-dessous pour recevoir le r√¥le **${ROLE_CONFIG.PROJECT_ROLE_NAME}**
‚Ä¢ Vous serez mentionn√© √† chaque nouveau projet publi√©
‚Ä¢ Recliquez sur ${ROLE_CONFIG.REACTION_EMOJI} pour retirer le r√¥le √† tout moment

**Avantages :**
üöÄ Soyez le premier inform√© des nouveaux projets
üéØ Trouvez rapidement des projets qui vous int√©ressent  
üë• Rejoignez des √©quipes talentueuses
üí° D√©couvrez de nouvelles technologies

**Projet SkillCraft :**
Plateforme collaborative pour d√©veloppeurs o√π vous pouvez cr√©er, rejoindre et d√©velopper des projets ensemble !`)
      .setColor('#3498db')
      .setFooter({ 
        text: 'Crafty ‚Ä¢ Syst√®me de notifications automatique',
        iconURL: client.user.displayAvatarURL()
      })
      .setTimestamp();

    // Envoyer le message
    const message = await channel.send({ 
      embeds: [embed],
      content: `**üéØ Syst√®me de notifications des projets**\n\nCliquez sur ${ROLE_CONFIG.REACTION_EMOJI} ci-dessous pour recevoir les notifications !`
    });

    // Ajouter la r√©action
    await message.react(ROLE_CONFIG.REACTION_EMOJI);
    
    console.log(`‚úÖ Message de r√¥le cr√©√© dans #${channel.name}`);
    return true;
    
  } catch (error) {
    console.error('‚ùå Erreur lors du setup du message de r√¥le:', error);
    return false;
  }
}

// Fonction pour obtenir la mention du r√¥le
async function getRoleMention(guild) {
  try {
    const role = guild.roles.cache.find(r => r.name === ROLE_CONFIG.PROJECT_ROLE_NAME);
    return role ? `<@&${role.id}>` : '';
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration r√¥le pour mention:', error);
    return '';
  }
}

// === Gestion des r√©actions ===

// Gestion des r√©actions ajout√©es
client.on('messageReactionAdd', async (reaction, user) => {
  try {
    // Ignorer les r√©actions du bot lui-m√™me
    if (user.bot) return;

    // V√©rifier si c'est la bonne r√©action
    if (reaction.emoji.name !== ROLE_CONFIG.REACTION_EMOJI) return;

    // R√©cup√©rer le membre
    const member = await reaction.message.guild.members.fetch(user.id);
    if (!member) return;

    // R√©cup√©rer ou cr√©er le r√¥le
    const role = await ensureProjectRole(reaction.message.guild);
    if (!role) {
      console.error('‚ùå Impossible de r√©cup√©rer le r√¥le');
      return;
    }

    // V√©rifier si le membre a d√©j√† le r√¥le
    if (member.roles.cache.has(role.id)) {
      console.log(`‚ÑπÔ∏è ${user.username} a d√©j√† le r√¥le ${ROLE_CONFIG.PROJECT_ROLE_NAME}`);
      return;
    }

    // Ajouter le r√¥le
    await member.roles.add(role);
    console.log(`‚úÖ R√¥le "${ROLE_CONFIG.PROJECT_ROLE_NAME}" ajout√© √† ${user.username}`);

    // Envoyer un message priv√© de confirmation
    try {
      const confirmEmbed = new EmbedBuilder()
        .setTitle('üéâ R√¥le ajout√© avec succ√®s !')
        .setDescription(`Vous avez maintenant le r√¥le **${ROLE_CONFIG.PROJECT_ROLE_NAME}** !`)
        .setColor('#2ecc71')
        .addFields(
          { 
            name: '‚úÖ Ce que cela signifie', 
            value: '‚Ä¢ Vous serez mentionn√© √† chaque nouveau projet\n‚Ä¢ Vous recevrez les notifications en temps r√©el\n‚Ä¢ Vous pourrez d√©couvrir de nouveaux projets rapidement', 
            inline: false 
          },
          { 
            name: 'üîÑ Pour retirer ce r√¥le', 
            value: `Retirez simplement votre r√©action ${ROLE_CONFIG.REACTION_EMOJI} sur le message`, 
            inline: false 
          }
        )
        .setFooter({ text: 'SkillCraft - Notifications' })
        .setTimestamp();

      await user.send({ embeds: [confirmEmbed] });
    } catch (dmError) {
      // L'utilisateur a peut-√™tre d√©sactiv√© les MPs
      console.log(`‚ÑπÔ∏è Impossible d'envoyer un MP √† ${user.username} (MPs d√©sactiv√©s)`);
    }

  } catch (error) {
    console.error('‚ùå Erreur lors de l\'ajout du r√¥le:', error);
  }
});

// Gestion des r√©actions retir√©es
client.on('messageReactionRemove', async (reaction, user) => {
  try {
    // Ignorer les r√©actions du bot lui-m√™me
    if (user.bot) return;

    // V√©rifier si c'est la bonne r√©action
    if (reaction.emoji.name !== ROLE_CONFIG.REACTION_EMOJI) return;

    // R√©cup√©rer le membre
    const member = await reaction.message.guild.members.fetch(user.id);
    if (!member) return;

    // R√©cup√©rer le r√¥le
    const role = reaction.message.guild.roles.cache.find(r => r.name === ROLE_CONFIG.PROJECT_ROLE_NAME);
    if (!role) {
      console.log(`‚ÑπÔ∏è R√¥le ${ROLE_CONFIG.PROJECT_ROLE_NAME} non trouv√©`);
      return;
    }

    // V√©rifier si le membre a le r√¥le
    if (!member.roles.cache.has(role.id)) {
      console.log(`‚ÑπÔ∏è ${user.username} n'a pas le r√¥le ${ROLE_CONFIG.PROJECT_ROLE_NAME}`);
      return;
    }

    // Retirer le r√¥le
    await member.roles.remove(role);
    console.log(`‚ûñ R√¥le "${ROLE_CONFIG.PROJECT_ROLE_NAME}" retir√© de ${user.username}`);

    // Message de confirmation en MP
    try {
      const confirmEmbed = new EmbedBuilder()
        .setTitle('üëã R√¥le retir√©')
        .setDescription(`Le r√¥le **${ROLE_CONFIG.PROJECT_ROLE_NAME}** a √©t√© retir√© de votre compte.`)
        .setColor('#e74c3c')
        .addFields(
          { 
            name: 'üì≠ Ce que cela signifie', 
            value: '‚Ä¢ Vous ne recevrez plus de notifications pour les nouveaux projets\n‚Ä¢ Vous pouvez le remettre √† tout moment', 
            inline: false 
          },
          { 
            name: 'üîÑ Pour remettre ce r√¥le', 
            value: `Cliquez √† nouveau sur ${ROLE_CONFIG.REACTION_EMOJI} sur le message de configuration`, 
            inline: false 
          }
        )
        .setFooter({ text: 'SkillCraft - Notifications' })
        .setTimestamp();

      await user.send({ embeds: [confirmEmbed] });
    } catch (dmError) {
      console.log(`‚ÑπÔ∏è Impossible d'envoyer un MP √† ${user.username} (MPs d√©sactiv√©s)`);
    }

  } catch (error) {
    console.error('‚ùå Erreur lors du retrait du r√¥le:', error);
  }
});

// === Gestion des commandes slash ===
client.on('interactionCreate', async (interaction) => {
  if (!interaction.isChatInputCommand()) return;

  const { commandName } = interaction;

  // Commande /infos existante
  if (commandName === 'infos') {
    try {
      const command = require('./infos.js');
      await command.execute(interaction);
    } catch (error) {
      console.error('‚ùå Erreur /infos:', error);
      await interaction.reply({ 
        content: '‚ùå Erreur lors de l\'ex√©cution de la commande.', 
        ephemeral: true 
      });
    }
  }

  // Commande /setup-roles
  if (commandName === 'setup-roles') {
    try {
      // V√©rifier les permissions
      if (!interaction.member.permissions.has(PermissionFlagsBits.ManageRoles)) {
        return await interaction.reply({
          content: '‚ùå Vous devez avoir la permission "G√©rer les r√¥les" pour utiliser cette commande.',
          ephemeral: true
        });
      }

      await interaction.deferReply();
      
      const success = await setupRoleMessage();
      
      if (success) {
        await interaction.editReply('‚úÖ Message de r√¥le cr√©√© avec succ√®s ! Les utilisateurs peuvent maintenant cliquer sur üîî pour recevoir les notifications.');
      } else {
        await interaction.editReply('‚ùå Erreur lors de la cr√©ation du message de r√¥le. V√©rifiez la configuration et les permissions.');
      }
    } catch (error) {
      console.error('‚ùå Erreur setup-roles:', error);
      await interaction.editReply('‚ùå Erreur lors de la cr√©ation du message de r√¥le.');
    }
  }

  // Commande /role-stats
  if (commandName === 'role-stats') {
    try {
      // V√©rifier les permissions
      if (!interaction.member.permissions.has(PermissionFlagsBits.ManageRoles)) {
        return await interaction.reply({
          content: '‚ùå Vous devez avoir la permission "G√©rer les r√¥les" pour utiliser cette commande.',
          ephemeral: true
        });
      }

      await interaction.deferReply();

      const guild = interaction.guild;
      const role = guild.roles.cache.find(r => r.name === ROLE_CONFIG.PROJECT_ROLE_NAME);
      
      if (!role) {
        return await interaction.editReply('‚ùå Le r√¥le "Projets" n\'existe pas encore. Utilisez `/setup-roles` d\'abord.');
      }

      const membersWithRole = role.members.size;
      const totalMembers = guild.memberCount;
      const percentage = totalMembers > 0 ? ((membersWithRole / totalMembers) * 100).toFixed(1) : '0.0';

      const embed = new EmbedBuilder()
        .setTitle('üìä Statistiques du Syst√®me de R√¥les')
        .setDescription('Voici les informations sur le syst√®me de notifications SkillCraft')
        .setColor('#3498db')
        .addFields(
          { name: 'üë• Membres avec le r√¥le', value: `${membersWithRole}`, inline: true },
          { name: 'üè† Total membres serveur', value: `${totalMembers}`, inline: true },
          { name: 'üìà Pourcentage', value: `${percentage}%`, inline: true },
          { name: 'üéØ Nom du r√¥le', value: `\`${role.name}\``, inline: true },
          { name: 'üîî Emoji utilis√©', value: ROLE_CONFIG.REACTION_EMOJI, inline: true },
          { name: 'üÜî ID du r√¥le', value: `\`${role.id}\``, inline: true },
          { name: 'üé® Couleur du r√¥le', value: `${role.hexColor}`, inline: true },
          { name: 'üìÖ R√¥le cr√©√© le', value: `<t:${Math.floor(role.createdTimestamp / 1000)}:D>`, inline: true },
          { name: 'üí¨ Mentionnable', value: role.mentionable ? '‚úÖ Oui' : '‚ùå Non', inline: true }
        )
        .setFooter({ text: 'Syst√®me de notifications SkillCraft' })
        .setTimestamp();

      await interaction.editReply({ embeds: [embed] });
      
    } catch (error) {
      console.error('‚ùå Erreur role-stats:', error);
      await interaction.editReply('‚ùå Erreur lors de la r√©cup√©ration des statistiques.');
    }
  }
});

// === Fonctions utilitaires pour les projets ===
function getDisplayName(user) {
  if (user.username) return user.username;
  if (user.firstName || user.lastName) {
    return [user.firstName, user.lastName].filter(Boolean).join(' ');
  }
  return 'Utilisateur anonyme';
}

function formatDifficulty(difficulty) {
  const difficulties = {
    'BEGINNER': 'üü¢ D√©butant',
    'INTERMEDIATE': 'üü° Interm√©diaire',
    'ADVANCED': 'üî¥ Avanc√©'
  };
  return difficulties[difficulty] || difficulty;
}

function formatStatus(status) {
  const statuses = {
    'PLANNING': 'üìã Planification',
    'OPEN': 'üü¢ Ouvert',
    'IN_PROGRESS': 'üöÄ En cours',
    'COMPLETED': '‚úÖ Termin√©',
    'ON_HOLD': '‚è∏Ô∏è En pause',
    'CANCELLED': '‚ùå Annul√©'
  };
  return statuses[status] || status;
}

function getStatusColor(status) {
  const colors = {
    'PLANNING': 0x95a5a6,     // Gris
    'OPEN': 0x2ecc71,        // Vert
    'IN_PROGRESS': 0x3498db, // Bleu
    'COMPLETED': 0x9b59b6,   // Violet
    'ON_HOLD': 0xf39c12,     // Orange
    'CANCELLED': 0xe74c3c    // Rouge
  };
  return colors[status] || 0x95a5a6;
}

// === Middleware d'authentification ===
function authenticateRequest(req, res, next) {
  const authHeader = req.headers.authorization;
  if (!authHeader) {
    return res.status(401).json({ error: 'Authorization header missing' });
  }
  
  const token = authHeader.split(' ')[1];
  if (!token || token !== process.env.PROJECT_SECRET) {
    return res.status(401).json({ error: 'Invalid or missing token' });
  }
  next();
}

// === Routes API pour les notifications de projets ===

// Route pour annoncer un nouveau projet
app.post('/announce-project', authenticateRequest, async (req, res) => {
  try {
    const projectData = req.body;
    
    // Validation des donn√©es minimales requises
    if (!projectData.title || !projectData.creator) {
      return res.status(400).json({ 
        error: 'Donn√©es manquantes (title et creator requis)' 
      });
    }

    const channelId = process.env.PROJECT_ANNOUNCE_CHANNEL_ID;
    const channel = await client.channels.fetch(channelId);

    if (!channel) {
      return res.status(404).json({ error: 'Salon Discord non trouv√©.' });
    }

    // Cr√©er l'embed Discord
    const embed = new EmbedBuilder()
      .setTitle('üöÄ Nouveau projet forg√©, il est pour toi celui-l√†!')
      .setDescription(`**${projectData.title}**\n${projectData.shortDesc || projectData.description?.substring(0, 150) + '...' || 'Aucune description'}`)
      .setColor(getStatusColor(projectData.status || 'PLANNING'))
      .setTimestamp(new Date(projectData.createdAt || Date.now()))
      .setFooter({ 
        text: `ID: ${projectData.id || 'N/A'}`,
      });

    // Informations du cr√©ateur
    const creatorName = getDisplayName(projectData.creator);
    embed.addFields({
      name: 'üë§ Cr√©ateur',
      value: creatorName,
      inline: true
    });

    // Difficult√©
    if (projectData.difficulty) {
      embed.addFields({
        name: 'üìä Difficult√©',
        value: formatDifficulty(projectData.difficulty),
        inline: true
      });
    }

    // Statut
    embed.addFields({
      name: 'üè∑Ô∏è Statut',
      value: formatStatus(projectData.status || 'PLANNING'),
      inline: true
    });

    // Technologies
    if (projectData.technologies && projectData.technologies.length > 0) {
      const techNames = projectData.technologies
        .slice(0, 8) // Limiter pour √©viter les messages trop longs
        .map(tech => {
          if (tech.skill) {
            return tech.skill.name;
          }
          return tech.name || tech;
        })
        .join(', ');
      
      embed.addFields({
        name: 'üíª Technologies',
        value: techNames + (projectData.technologies.length > 8 ? ` et ${projectData.technologies.length - 8} autres...` : ''),
        inline: false
      });
    }

    // Informations sur l'√©quipe
    let memberInfo = '';
    if (projectData.members && projectData.members.length > 0) {
      memberInfo = `${projectData.members.length} membre(s)`;
    } else if (projectData.currentMembers) {
      memberInfo = `${projectData.currentMembers} membre(s)`;
    } else {
      memberInfo = '1 membre'; // Au minimum le cr√©ateur
    }

    if (projectData.maxMembers) {
      memberInfo += ` / ${projectData.maxMembers} max`;
    }

    // V√©rifier si le projet accepte des candidatures
    const isOpen = projectData.status === 'OPEN' || projectData.status === 'PLANNING';
    if (isOpen && (!projectData.maxMembers || (projectData.currentMembers || 1) < projectData.maxMembers)) {
      memberInfo += ' - üü¢ Ouvert aux candidatures';
    }

    embed.addFields({
      name: 'üë• √âquipe',
      value: memberInfo,
      inline: false
    });

    // Lien vers le projet pour rejoindre
    const projectUrl = `${process.env.SKILLCRAFT_URL || 'https://skillcraft.dev'}/projects/${projectData.id}`;
    
    embed.addFields({
      name: 'üéØ Rejoindre le projet',
      value: `[üëâ Cliquez ici pour rejoindre !](${projectUrl})`,
      inline: false
    });

    // Ajouter une image si disponible
    if (projectData.image) {
      embed.setThumbnail(projectData.image);
    }

    // R√©cup√©rer la mention du r√¥le
    const roleMention = await getRoleMention(channel.guild);
    let messageContent = isOpen ? 'üéØ **Rejoignez cette aventure !**' : 'üéØ **Nouveau projet disponible !**';
    
    if (roleMention) {
      messageContent += `\n\n${roleMention} Un nouveau projet vous attend ! üöÄ`;
    }

    // Envoyer le message avec l'embed
    await channel.send({ 
      embeds: [embed],
      content: messageContent
    });

    console.log(`‚úÖ Annonce envoy√©e pour le projet: ${projectData.title}`);
    res.status(200).json({ 
      success: true, 
      message: 'Annonce envoy√©e avec succ√®s' 
    });

  } catch (error) {
    console.error('‚ùå Erreur lors de l\'annonce du projet:', error);
    res.status(500).json({ 
      error: 'Erreur interne du serveur',
      details: error.message 
    });
  }
});

// Route pour annoncer une mise √† jour de projet
app.post('/announce-project-update', authenticateRequest, async (req, res) => {
  try {
    const { projectData, updateType = 'general' } = req.body;
    
    if (!projectData.title || !projectData.creator) {
      return res.status(400).json({ 
        error: 'Donn√©es manquantes' 
      });
    }

    const channelId = process.env.PROJECT_ANNOUNCE_CHANNEL_ID;
    const channel = await client.channels.fetch(channelId);

    if (!channel) {
      return res.status(404).json({ error: 'Salon Discord non trouv√©.' });
    }

    const updateTitles = {
      'status': 'üìä Projet mis √† jour !',
      'members': 'üë• Nouvelle recrue !',
      'general': '‚úèÔ∏è Projet mis √† jour !',
      'completed': 'üéâ Projet termin√© !'
    };

    const embed = new EmbedBuilder()
      .setTitle(updateTitles[updateType] || updateTitles.general)
      .setDescription(`**${projectData.title}**\n${projectData.shortDesc || 'Mise √† jour du projet'}`)
      .setColor(getStatusColor(projectData.status))
      .setTimestamp()
      .setFooter({ text: `ID: ${projectData.id}` });

    // Informations basiques
    embed.addFields(
      {
        name: 'üë§ Cr√©ateur',
        value: getDisplayName(projectData.creator),
        inline: true
      },
      {
        name: 'üè∑Ô∏è Statut',
        value: formatStatus(projectData.status),
        inline: true
      }
    );

    // Lien vers le projet
    const projectUrl = `${process.env.SKILLCRAFT_URL || 'https://skillcraft.dev'}/projects/${projectData.id}`;
    embed.addFields({
      name: 'üéØ Voir le projet',
      value: `[üëâ Cliquez ici](${projectUrl})`,
      inline: false
    });

    // Mentionner le r√¥le pour les mises √† jour importantes
    let messageContent = '';
    if (updateType === 'completed') {
      const roleMention = await getRoleMention(channel.guild);
      if (roleMention) {
        messageContent = `${roleMention} F√©licitations pour ce projet termin√© ! üéâ`;
      }
    }

    await channel.send({ 
      embeds: [embed],
      content: messageContent
    });

    console.log(`‚úÖ Mise √† jour envoy√©e pour le projet: ${projectData.title}`);
    res.status(200).json({ 
      success: true, 
      message: 'Mise √† jour annonc√©e' 
    });

  } catch (error) {
    console.error('‚ùå Erreur mise √† jour:', error);
    res.status(500).json({ 
      error: 'Erreur interne du serveur' 
    });
  }
});

// Route de test pour v√©rifier que le bot fonctionne
app.get('/test', (req, res) => {
  res.json({ 
    status: 'Bot Discord actif',
    user: client.user?.tag || 'Non connect√©',
    timestamp: new Date().toISOString(),
    roleSystem: {
      roleName: ROLE_CONFIG.PROJECT_ROLE_NAME,
      emoji: ROLE_CONFIG.REACTION_EMOJI,
      channelConfigured: !!ROLE_CONFIG.PROJECT_ANNOUNCE_CHANNEL_ID
    }
  });
});

// Gestion des erreurs Discord
client.on('error', (error) => {
  console.error('‚ùå Erreur Discord:', error);
});

// Gestion des erreurs de processus
process.on('unhandledRejection', (reason, promise) => {
  console.error('‚ùå Unhandled Rejection at:', promise, 'reason:', reason);
});

process.on('uncaughtException', (error) => {
  console.error('‚ùå Uncaught Exception:', error);
  process.exit(1);
});

// === D√©marrage du bot et du serveur ===
client.login(process.env.BOT_TOKEN)
  .then(() => {
    app.listen(3001, () => {
      console.log('üåê Serveur API en √©coute sur le port 3001');
      console.log('ü§ñ Bot Discord pr√™t pour les notifications de projets !');
      console.log(`üîî Syst√®me de r√¥les configur√© avec l'emoji ${ROLE_CONFIG.REACTION_EMOJI}`);
      console.log('');
      console.log('üìã Commandes disponibles :');
      console.log('   ‚Ä¢ /infos - Statistiques du site');
      console.log('   ‚Ä¢ /setup-roles - Cr√©er le syst√®me de r√¥les');
      console.log('   ‚Ä¢ /role-stats - Statistiques des r√¥les');
      console.log('');
      console.log('üöÄ Bot pr√™t √† recevoir les notifications !');
    });
  })
  .catch((error) => {
    console.error('‚ùå Erreur de connexion Discord:', error);
    process.exit(1);
  });